<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>I am an Engineer</title>
    <link>http://varunksaini.com/</link>
    <description>Recent content on I am an Engineer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2015 Copyright Text</copyright>
    <lastBuildDate>Sat, 19 Sep 2015 19:58:28 -0600</lastBuildDate>
    <atom:link href="http://varunksaini.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Podcasts I listen</title>
      <link>http://varunksaini.com/posts/fav-podcasts/</link>
      <pubDate>Sat, 19 Sep 2015 19:58:28 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/fav-podcasts/</guid>
      <description>&lt;p&gt;I find podcasts informative and entertaining. Every week I listen to at least 3-4 hours of podcasts. I can only listen to podcasts when I am in gym or in car. I can not listen while working because of distraction and I do not want to be hit by cars, so I also do not listen while walking. But it seems that I can still get at least 4-5 hours every week and that&amp;rsquo;s enough time to listen to most of these podcasts.&lt;/p&gt;

&lt;p&gt;These are the podcasts that I listen to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.motherjones.com/category/secondary-tags/inquiring-minds&#34;&gt;Inquiring minds&lt;/a&gt; - This is my favorite science podcast. The topics are diverse and hosts are really good.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.npr.org/sections/money/&#34;&gt;Planet Money&lt;/a&gt; - Who would not like Planet Money. It is informative and interesting at the same time.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://99percentinvisible.org/&#34;&gt;99% Invisible&lt;/a&gt; - A podcast about design, architecture and other interesting things related to them.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://freakonomics.com/category/freakonomics-radio/podcasts/&#34;&gt;Freakonomics Radio&lt;/a&gt; - This is my favorite too. If you are interested in economics/phycology and their impacts on world, Do not miss this podcast.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hanselminutes.com/&#34;&gt;Hanselminutes&lt;/a&gt; - My only dev podcast. Scott Hanselman  talks to people about different technologies and ideas.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.thisamericanlife.org/&#34;&gt;This American Life&lt;/a&gt; - This is also a popular podcast. Topics are diverse and interesting.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nerdist.com/podcasts/nerdist-podcast-channel/&#34;&gt;The Nerdist&lt;/a&gt; - If you like stand up comedy and want to listen to some interesting people talk in very open environment, this is the podcast for you.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I also listen to some other podcasts if I find some interesting topic, otherwise these are the podcast that I listen to.&lt;/p&gt;

&lt;p&gt;What are the podcasts that you guys like, Please share.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>running commands with go</title>
      <link>http://varunksaini.com/posts/running_commands_with_go/</link>
      <pubDate>Sun, 12 Jul 2015 19:58:28 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/running_commands_with_go/</guid>
      <description>&lt;p&gt;Sometimes we need to run external commands programatically to use the output of the command to drive the execution. Go provides a nice interface to run the external commands through &lt;a href=&#34;https://golang.org/pkg/os/exec/&#34;&gt;exec&lt;/a&gt; package. Running an external command is very easy and an example is given below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os/exec&amp;quot;
)

func main() {
	out, err := exec.Command(&amp;quot;date&amp;quot;).Output()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf(&amp;quot;The time is %s\n&amp;quot;, out)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; package provides some other useful methods to work with external commands. Use this powerful package to build awesome things.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My Go Lang Development Workflow</title>
      <link>http://varunksaini.com/posts/go_dev_workflow/</link>
      <pubDate>Sat, 13 Jun 2015 11:11:00 -0900</pubDate>
      
      <guid>http://varunksaini.com/posts/go_dev_workflow/</guid>
      <description>&lt;p&gt;I have been doing programming in Go from last 6 months. When you start a new project or start learning a new programming language, chossing your tools(text editor, plugins etc.) is as important as any other process.&lt;/p&gt;

&lt;p&gt;I use Sublime Text 3 with &lt;a href=&#34;https://github.com/DisposaBoy/GoSublime&#34;&gt;go-sublime&lt;/a&gt; plugin as my text editor. go-sublime adds many features to Sublime Text for go development and make the whole development process a little easier. I particularly like &amp;lsquo;go linting&amp;rsquo; and &amp;lsquo;go to definition&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src=&#34;http://varunksaini.com/img/sublime.png&#34; alt=&#34;Sublime Text&#34; title=&#34;Sublime Text&#34; style=&#34;width:700px; height: 500px;&#34;&gt;
&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Once I have written the code and tests, I run &lt;code&gt;go test&lt;/code&gt; in terminal (I use iterm2 instead of default terminal app) to test my code. To check code coverage, I run &lt;code&gt;go test -cover&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;because sometime you need more than one terminal window, I use &lt;a href=&#34;http://tmux.github.io/&#34;&gt;tmux&lt;/a&gt; for that. tmux manages terminal windows and sessions. I started using tmux some time back and it is great.&lt;/p&gt;

&lt;p&gt;OSX window management is a pain in itself, I use &lt;a href=&#34;http://mizage.com/divvy/&#34;&gt;DIVVY&lt;/a&gt; to manage the windows. I am looking forward to &lt;a href=&#34;http://www.apple.com/osx/elcapitan-preview/&#34;&gt;OSX el capitan&lt;/a&gt;, which has window management build in the OSX (finally).&lt;/p&gt;

&lt;p&gt;Once I have tested my code thoroughly on my local machine, I send it to github for code review. I generally use git in terminal to run all the common git commands (such as &lt;code&gt;git status&lt;/code&gt;, &lt;code&gt;git commit&lt;/code&gt;, and &lt;code&gt;git push&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We use &lt;a href=&#34;http://github.com/MediaMath/grim&#34;&gt;GRIM&lt;/a&gt;, which is open sourced by the way, as our build server. So when I create a pull request for code review, grim takes the pull request and run the build to make sure that everything works as expected with new code, grim also updates the hipchat channel, so that team is aware about new pull request.&lt;/p&gt;

&lt;p&gt;This continous build system gives code reviewers a test run even before reviewing the code. Once the code review is done and thumpsup are given, code is ready to be merged in master.&lt;/p&gt;

&lt;p&gt;Once merged, time for next task and more Go code/learnings..&lt;/p&gt;

&lt;p&gt;Note: If you are a vim user, then &lt;a href=&#34;https://github.com/fatih/vim-go&#34;&gt;vim-go&lt;/a&gt; is an awesome go plugin for vim.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>using io.SectionReader in Go</title>
      <link>http://varunksaini.com/posts/using-sectionReader/</link>
      <pubDate>Sun, 31 May 2015 06:30:00 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/using-sectionReader/</guid>
      <description>&lt;p&gt;For my last task I was moving to an offset value in huge byte stream using &lt;code&gt;reader.Seek(int64(offset), whence)&lt;/code&gt; and reading the bytes there. But it was not good for the performance because I was moving in a big file(~1gigs). Then I came to know about &lt;code&gt;io.SectionReader&lt;/code&gt; and it made my life easier and helped me delete a lot of code(isn&amp;rsquo;t that best).&lt;/p&gt;

&lt;p&gt;I create the section reader using this function:&lt;/p&gt;

&lt;pre&gt;
func GetByteSection(pageBlock []byte, offset int64, sectionLength int64) *io.SectionReader {
    reader := bytes.NewReader(pageBlock)
    section := io.NewSectionReader(reader, offset, sectionLength)
    return section
}
&lt;/pre&gt;

&lt;p&gt;Then I read it like:&lt;/p&gt;

&lt;pre&gt;
tupleSection := GetByteSection(block, int64(headerOffset), int64(headerLength))
err = binary.Read(tupleSection, binary.LittleEndian, &amp;data)
if err != nil {
    return nil, fmt.Errorf(&#34;failed to read t_bits: %v\n&#34;, err)
}
&lt;/pre&gt;

&lt;p&gt;life has been easier with more &lt;a href=&#34;http://golang.org/pkg/io/#SectionReader&#34;&gt;sectionReader&lt;/a&gt; and less Seeks.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Lang notes</title>
      <link>http://varunksaini.com/posts/notes-from-Go-In-Action-book/</link>
      <pubDate>Mon, 25 May 2015 19:58:00 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/notes-from-Go-In-Action-book/</guid>
      <description>&lt;p&gt;I got &lt;a href=&#34;http://www.manning.com/ketelsen/&#34;&gt;Go In Action&lt;/a&gt; book from &lt;a href=&#34;https://twitter.com/goinggodotnet&#34;&gt;William Kennedy&lt;/a&gt;. I was reading the book last week and I have a habit of taking some noted while reading. The book takes a very pragmatic approach to teach &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; and has very good code  examples. I am sharing some of the notes I took while reading the book. If anybody find the notes interesting, he/she can check the book also.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The empty interface is an interface implemented by every type.Interfaces allow you to express the capabilities of a type. If a type implements an interface, it means that a type has a specific set of capabilities.&lt;/li&gt;
&lt;li&gt;In Go, if your type implements the methods of an interface, it can be used anywhere that interface is expected, no declaration required.
One of the most common interfaces you will use in Go is the io.Reader. The io.Reader interface provides a simple way to declare that your type has data to be read in a way that other functions in the standard library understand.
For the build tools to produce an executable, the function &lt;strong&gt;main&lt;/strong&gt; must be declared and it becomes the entry point for the program.&lt;/li&gt;
&lt;li&gt;If our main function does not exist in package main, the build tools will not produce an executable.&lt;/li&gt;
&lt;li&gt;When we import code from the standard library, we only need to reference the name of the package unlike when we import code from outside of the standard library.&lt;/li&gt;
&lt;li&gt;The compiler will always look for the packages we import at the locations referenced by the &lt;strong&gt;GOROOT&lt;/strong&gt; and &lt;strong&gt;GOPATH&lt;/strong&gt; environment variables
In Go, identifiers are either exported or unexported from a package. An exported identifier can be directly accessed by code in other packages when the respective package is imported. These identifiers start with a capital letter. Unexported identifiers start with a lowercase letter and can&amp;rsquo;t be directly accessed by code in other packages.&lt;/li&gt;
&lt;li&gt;In Go, all variables are initialized to their zero value. For numeric types that value is 0, for strings it is an empty string, for boolean it is false and for pointers the zero value is nil. When it comes to reference types, there are underlying data structures that are initialized to their zero values. However, variables declared as a reference type set to their zero value will return the value of nil.&lt;/li&gt;
&lt;li&gt;A slice is a reference type that implements a dynamic array. We use slices in Go to work with lists of data.&lt;/li&gt;
&lt;li&gt;Channels are also a reference type in Go like maps and slices, but channels implement a queue of typed values that are used to communicate data between goroutines. Channels provide inherent synchronization mechanisms to make communication safe.&lt;/li&gt;
&lt;li&gt;Pointer variables are great for sharing variables between functions. They allow functions to access and change the state of a variable that was declared within the scope of a different function and possibly a different goroutine.&lt;/li&gt;
&lt;li&gt;In Go, all variables are passed by value. Since the value of a pointer variable is the address to the memory being pointed to, passing pointer variables between functions is still considered a pass by value.&lt;/li&gt;
&lt;li&gt;All .go files must declare the package that they belong to as the first line of the file excluding whitespace and comments. Packages are contained in a single directory. You may not have multiple packages in the same directory, nor may you split a package across multiple directories. This means that all .go files in a single directory must declare the same package name.&lt;/li&gt;
&lt;li&gt;The compiler will stop searching once it finds a package that satisfies the import statement. The important thing to remember is that the Go installation directory is the first place the compiler looks, then each directory listed in your GOPATH in the order that they are listed.&lt;/li&gt;
&lt;li&gt;you could have a utilities package for handling network code in one directory and a utilities package for handling text files in another directory. You can import both packages in the same program without confusion by placing an alias name in front of the package location. This process is called package aliasing because you are changing the name of the imported package when you import it.&lt;/li&gt;
&lt;li&gt;Blank Identifier: The &lt;strong&gt;_ (underscore character)&lt;/strong&gt; is known as the blank identifier and has many uses within Go. It&amp;rsquo;s used when you want to throw away the assignment of a value, including the assigment of an import to it&amp;rsquo;s package name, or ignoring return values from a function when you&amp;rsquo;re only interested in the others.&lt;/li&gt;
&lt;li&gt;Each package has the ability to provide an &lt;strong&gt;init method&lt;/strong&gt; that is invoked at the beginning of execution time. This method allows you to setup your package, initialize variables, or any other bootstrapping you may need for your package.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;go run&lt;/strong&gt; command both builds and executes the program.&lt;/li&gt;
&lt;li&gt;An array in Go is a fixed length data type that contains a contiguous block of elements of the same type. This could be a built-in type such as integers and strings, or it can be a struct type.&lt;/li&gt;
&lt;li&gt;When variables in Go are declared, they are always initialized with their zero value for their respective type and arrays are no different. When an array is initialized, each individual element that belongs to the array is initialized to its zero value.&lt;/li&gt;
&lt;li&gt;If the length is given as &amp;hellip;, Go will identify the length of the array based on the number of elements that are initialized:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;An array is a value in Go&lt;/strong&gt;. This means we can use it in an assignment operation. The variable name denotes the entire array and therefore, an array can be assigned to other arrays of the same type.&lt;/li&gt;
&lt;li&gt;Passing an array between functions can be an expensive operation in terms of memory and performance. When we pass variables between functions, they are always passed by value. When our variable is an array, this means the entire array, regardless of its size, is copied and passed to the function.&lt;/li&gt;
&lt;li&gt;Remember, if we specify a value inside the [ ] operator, we are creating an array. If we don&amp;rsquo;t specify a value, we are creating a slice:&lt;/li&gt;
&lt;li&gt;For slice[i:j] with an underlying array of capacity k, &lt;strong&gt;Length: j - i&lt;/strong&gt; and &lt;strong&gt;Capacity: k - i&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;One of the advantages of using a slice over an array is that we can grow the capacity of our slice as needed. Go takes care of all the operational details when we use the built-in function append.&lt;/li&gt;
&lt;li&gt;The append operation is clever when growing the capacity of the underlying array. Capacity is always doubled when the existing capacity of the slice is under one thousand (1k) elements. Once the number of elements goes over 1k, the capacity is grown by a factor of 1.25 or 25%. This growth algorithm may change in the language over time.&lt;/li&gt;
&lt;li&gt;The built-in function append is also a variadic function. This means we can pass multiple values to be appended in a single slice call. If we use the (&amp;hellip;) operator, we can append all the elements of one slice into another&lt;/li&gt;
&lt;li&gt;Since a slice is a collection, we can iterate over the elements. Go has a special keyword called &lt;strong&gt;range&lt;/strong&gt; that we use in conjunction with the keyword &lt;strong&gt;for&lt;/strong&gt; to iterate over slices.&lt;/li&gt;
&lt;li&gt;The keyword range when iterating over a slice will return two values. The first value is the &lt;strong&gt;index&lt;/strong&gt; position and the second &lt;strong&gt;value&lt;/strong&gt; is a copy of the value in that index position.&lt;/li&gt;
&lt;li&gt;It is important to know that range is making a copy of the value, not returning a reference. If we use the address of the value variable as a pointer to each element, we will be making a mistake.&lt;/li&gt;
&lt;li&gt;Passing a slice between two functions requires nothing more than passing the slice by value. Since the size of a slice is small, it is cheap to copy and pass between functions.&lt;/li&gt;
&lt;li&gt;On a 64 bit architecture, a slice requires 24 bytes of memory. The pointer field requires 8 bytes and the length and capacity fields require 8 bytes respectively. Since the data associated with a slice is contained in the underlying array, there are no problems passing a copy of a slice to any function. Only the slice is being copied, not the underlying array.&lt;/li&gt;
&lt;li&gt;A map is a data structure that provides us with an unordered collection of key/value pairs.&lt;/li&gt;
&lt;li&gt;The strength of a map is its ability to retrieve data quickly based on the key. A key works like an index, pointing to the value we associate with that key.&lt;/li&gt;
&lt;li&gt;A bool requires 1 byte of memory (8 bits) and represents a boolean value of true or false. (Computers can’t address anything less than a byte, that’s why it is 1 byte and not 1 bit).&lt;/li&gt;
&lt;li&gt;Some types get their representation based on the architecture of the machine the code is built for. A value of type int for example, can either have a size of 8 bytes (64 bits) or 4 bytes (32 bits) depending on the architecture.&lt;/li&gt;
&lt;li&gt;When we declare variables, the value that the variable represents is always initialized. The value can be initialized with a specific value or it can be initialized to its zero value, which is the default value for that variables type. For numeric types, the zero value would be 0, for strings it would be empty and for booleans it would be false. In the case of a struct, the zero value would apply to all the different fields in the struct.&lt;/li&gt;
&lt;li&gt;When a function has a receiver, we call that function a method. (could be a pointer receiver or value receiver).&lt;/li&gt;
&lt;li&gt;There are two types of receivers in Go, &lt;strong&gt;value receivers&lt;/strong&gt; and &lt;strong&gt;pointer receivers&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;When we declare a method using a value receiver, the method will always be operating against a copy of the value used to make the method call.&lt;/li&gt;
&lt;li&gt;Value receivers operate on a copy of the value used to make the method call and pointer receivers operate on the actual value.&lt;/li&gt;
&lt;li&gt;We can also call methods that are declared with a pointer receiver using a value.&lt;/li&gt;
&lt;li&gt;Think about types as having one of two natures: &lt;strong&gt;primitive&lt;/strong&gt; or &lt;strong&gt;non-primitive&lt;/strong&gt;. Primitive types create values that should not be shared. When different parts of our program need a primitive value, they should receive a copy and not a pointer to the value. Values that are created using a built-in or reference type exhibit this primitive nature.&lt;/li&gt;
&lt;li&gt;Non-primitive types create values that should be shared. When different parts of our program need a non-primitive value, they should receive a pointer to the value and not a copy. Values that are created using struct types exhibit this non-primitive nature.&lt;/li&gt;
&lt;li&gt;The built-in types are the set of types that are provided to us by the language. We know them as the set of numeric, string and boolean types. These types have a primitive nature to them. Because of this, values based on these types should be copied when passed to functions and methods.&lt;/li&gt;
&lt;li&gt;Struct types can be implemented to have either a primitive or non-primitive nature.&lt;/li&gt;
&lt;li&gt;Reference types in Go are the set of slice, map, channel, interface and function types.&lt;/li&gt;
&lt;li&gt;When we declare a variable from one of these types, the value that is created is called a header value. All the different header values from the different reference types contain a pointer to an underlying data structure. As well, each reference type also contains a set of unique fields that are used to manage the underlying data structure. We never share reference type values because the header value is designed to be copied. The header value contains a pointer, therefore you can pass a copy of any header value and share the underlying data structure intrinsically.&lt;/li&gt;
&lt;li&gt;Interfaces are types that just declare behavior. This behavior is never implemented by the interface type directly, but instead by user-defined types via methods. When a user-defined type implements the set of methods declared by an interface type, values of the user-defined type can be assigned to values of the interface type. This assignment stores the value of the user-defined type into the interface value.&lt;/li&gt;
&lt;li&gt;It says that values of type T only have as part of its method set, methods declared with a value receiver. However, pointers of type T have as part of its method set, methods declared with both value and pointer receivers.&lt;/li&gt;
&lt;li&gt;It says that if you implement an interface using a pointer receiver, then only pointers of that type implement the interface. If you implement an interface using a value receiver, then both values and pointers of that type implement the interface.&lt;/li&gt;
&lt;li&gt;Go allows you to take existing types and both extend or change their behavior. This capability is important for code reuse and for changing the behavior of an existing type to suit a new need. This is accomplished through &lt;strong&gt;type embedding&lt;/strong&gt;. It works by taking an existing type and declaring that type within the declaration of a new struct type. The type that is embedded is then called an inner type of the new &amp;ldquo;outer&amp;rdquo; type.&lt;/li&gt;
&lt;li&gt;When inner type as well as outer type has two separate implementation for an interface, inner type’s implementation is not promoted for outer type. otherwise it is promoted.&lt;/li&gt;
&lt;li&gt;When you are writing code that will live in its own package, it is good practice to name the package the same as the folder the code is in. All the Go tooling expects this convention so it is a good practice to follow.&lt;/li&gt;
&lt;li&gt;When an identifier starts with a lowercase letter, the identifier is unexported or unknown to code outside the package. When an identifier starts with an uppercase letter, it is exported or known to code outside the package.&lt;/li&gt;
&lt;li&gt;The Go runtime has a sophisticated piece of software called the &lt;strong&gt;scheduler&lt;/strong&gt; that manages all the goroutines that are created and need processor time. The scheduler is special because it sits on top of the operating system and controls everything related to the running of goroutines. No scheduling is done by the operating system.&lt;/li&gt;
&lt;li&gt;Go runtime limits each program to a &lt;strong&gt;maximum of 10,000&lt;/strong&gt; threads by default. This value can be changed by calling the SetMaxThreads function from the runtime package. If any program attempts to use more threads, the program crashes.&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;WaitGroup&lt;/strong&gt; is a semaphore that can be used to maintain a record of running goroutines. When the value of a WaitGroup is greater than zero, the Wait method will block.&lt;/li&gt;
&lt;li&gt;The keyword &lt;strong&gt;defer&lt;/strong&gt; is used to schedule other functions to be called when the function returns.&lt;/li&gt;
&lt;li&gt;The runtime package provides support for changing Go runtime configuration parameters.&lt;/li&gt;
&lt;li&gt;When two or more goroutines have unsynchronized access to a shared resource and attempt to read and write to that resource at the same time, we have what is called a race condition.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Atomic functions&lt;/strong&gt; provide a low-level locking mechanisms for synchronizing access to integers and pointers.&lt;/li&gt;
&lt;li&gt;Another way to synchronize access to a shared resource is by using a mutex. A mutex is named after the concept of mutual exclusion. A mutex is used to create a critical section around code that ensures only one goroutine at a time can execute that code section.&lt;/li&gt;
&lt;li&gt;When a resource needs to be shared between goroutines, channels act as a conduit between the goroutines and provide a mechanism that guarantees a synchronous exchange. When declaring a channel, the type of data that will be shared needs to be specified. Values and pointers of built-in, named, struct and reference types can be shared through a channel.&lt;/li&gt;
&lt;li&gt;An &lt;strong&gt;unbuffered channel&lt;/strong&gt; is a channel with no capacity to hold any value before it is received. These types of channels require both a sending and receiving goroutine to be ready at the same instant before any send or receive operation can complete.&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;buffered channel&lt;/strong&gt; is a channel with capacity to hold one or more values before they are received. These types of channels don&amp;rsquo;t force goroutines to be ready at the same instant to perform sends and receives. There are also different conditions for when a send or receive does block. A receive will only block if there is no value in the channel to receive. A send will only block if there is no available buffer to place the value being sent. This leads to the one big difference between unbuffered and buffered channels. An unbuffered channel provides a guarantee that an exchange between two goroutines is performed at the instant the send and receive take place. A buffered channel has no such guarantee.&lt;/li&gt;
&lt;li&gt;The Fatal family of functions are used to write a log message and then terminate the program using the &lt;strong&gt;os.Exit(1)&lt;/strong&gt; function call. The Panic family of functions are used to write a log message and then issue a panic, which unless recovered, will cause the program to terminate and stack trace. The Print family of functions are the standard way to write log messages.&lt;/li&gt;
&lt;li&gt;One nice thing about the log package, is that loggers are multi goroutine safe. This means that multiple goroutines at the same time can call these functions from the same logger value without the writes colliding with each other.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>goto Chicago Conference 2015</title>
      <link>http://varunksaini.com/posts/goto-chicago-2015/</link>
      <pubDate>Wed, 13 May 2015 20:41:00 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/goto-chicago-2015/</guid>
      <description>

&lt;p&gt;This week I went to GOTO Chicago conference. It was held in Westin hotel on Clark street. The conference was on 11th and 12th May 2015. GOTO is an yearly conference and has been going on from some time. My employer sponsored the conference also.&lt;/p&gt;

&lt;p&gt;It was a great conference and had a mix of talks on Programming Languages, Distributed Computing, Testing, General (Agile) etc. I attended bunch of talks delivered by some wonderful speakers.&lt;/p&gt;

&lt;h2 id=&#34;monday:e6b5a84ca155978c9ccb3cf2263b1856&#34;&gt;Monday&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src=&#34;http://varunksaini.com/img/gotopic.png&#34; alt=&#34;GOTO conf Chicago 2015&#34; title=&#34;GOTO Conf&#34; style=&#34;width:700px; height: 500px;&#34;&gt;
&lt;quote &gt; By Anita Sengupta(Shared on Twitter)&lt;/quote&gt;
&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Curiosity’s Entry Descent and Landing on Mars by Anita Sengupta(&lt;a href=&#34;https://twitter.com/Doctor_Astro&#34;&gt;@Doctor_Astro&lt;/a&gt;)&lt;/strong&gt; - Who doesn&amp;rsquo;t love space and space exploration. This was ending keynote and Anita made it one to remember for the ages. She talked about how Nasa JPL team managed to land a robot on Mars surface with state of the art technology and lots of hard work. Anita worked on &lt;strong&gt;Curiosity&lt;/strong&gt; mars rover and built the supersonic parachute used by the rover. She is currently working as a project manager for &amp;ldquo;Cold Atom Laboratory&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jepsen IV: Hope Springs Eternal by Kyle Kingsbury(&lt;a href=&#34;https://twitter.com/aphyr&#34;&gt;@aphyr&lt;/a&gt;) &lt;/strong&gt; -  Kyle is famous for his distributed database testing tool called Jespen. Kyle is a very good speaker and his slides were top class. If you are in distributed computing or databases, check out Kyle&amp;rsquo;s work.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/KyleKingsbury_JepsenIVHopeSpringsEternal.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Applying Reactive Programming with RxJava by Ben Christensen from Netflix(&lt;a href=&#34;https://twitter.com/benjchristensen&#34;&gt;@benjchristensen&lt;/a&gt;)&lt;/strong&gt; - The talk was about Java and Rx by Netflix. Good talk about writing async code in Java and How Netflix does it. It was good to see how another programming language apart from Go doing async and concurrency.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/BenChristensen_ApplyingReactiveProgrammingWithRx.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deploy like a Boss by Oliver Nicholas(&lt;a href=&#34;https://twitter.com/wonlove&#34;&gt;@wonlove&lt;/a&gt;)&lt;/strong&gt; - In this talk Oliver talked about how Uber deploys to production. They started with shell scripts but now they use Mesos + Marathon for deployment.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Patterns for Docker Success by Simon Eskildsen(&lt;a href=&#34;https://twitter.com/sirupsen&#34;&gt;@sirupsen&lt;/a&gt;)&lt;/strong&gt; - Simon was a great presenter and he talked about how Shopify is using Docker. He talked about what other companies trying to use Docker can use from Shopify experience.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/SimonEskildsen_PatternsForDockerSuccess.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How I finally stopped worrying and learnt to love Conway’s Law by James Lewis(&lt;a href=&#34;https://twitter.com/boicy&#34;&gt;@boicy&lt;/a&gt;)&lt;/strong&gt;
&lt;strong&gt;Evolutionary Architecture &amp;amp; Micro-Services - A Match Enabled by Continuous Delivery by Rebecca Parsons(&lt;a href=&#34;https://twitter.com/rebeccaparsons&#34;&gt;@rebeccaparsons&lt;/a&gt;)&lt;/strong&gt; - Both of these talks were about Micro-services architecture and how organizations can benefit with Micro-services. Rebecca even talked about when to use micro-services. She suggested that if you are building a new system you should start with a monolith architecture but with good design and then move to micro-services. If you start with micro services, you might define the boundaries of your system wrong.
&lt;br&gt;
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/JamesLewis_HowIFinallyStoppedWorryingAndLearntToLoveConwaysLaw.pdf&#34;&gt;Slides from James Lewis talk&lt;/a&gt;
&lt;br&gt;
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/RebeccaParsons_EvolutionaryArchitectureMicroServicesAMatchEnabledByContinuousDelivery.pdf&#34;&gt;Slides from Rebecca Parsons talk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;End-to-end Encryption in Cloud Services by Patrick Linskey&lt;/strong&gt; - This is the talk that I could not understand much. Speaker tried his best but either crypto is hard or end to end encryption is very hard. &lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/PatrickLinskey_EndToEndEncryptionInCloudServices.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tuesday:e6b5a84ca155978c9ccb3cf2263b1856&#34;&gt;Tuesday&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;How did we end up Here by Martin Thompson(&lt;a href=&#34;https://twitter.com/mjpt777&#34;&gt;@mjpt777&lt;/a&gt;) and Todd Montgomery(&lt;a href=&#34;https://twitter.com/toddlmontgomery&#34;&gt;@toddlmontgomery&lt;/a&gt;)&lt;/strong&gt; - Martin and Todd talked about current trends and issues with software development. They talked about increasing complexity and how to solve the problem. They also talked about diversity issues in Software engineering field.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf&#34;&gt;Slide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Level Up Your Automated Tests by Trisha Gee(&lt;a href=&#34;https://twitter.com/trisha_gee&#34;&gt;@trisha_gee&lt;/a&gt;)&lt;/strong&gt; - This was one of the talk from testing track. Trisha talked about how to have the culture of writing tests. She said that tests can be used as a documentation also and that resonated very well with everybody in the room. She also gave some examples from her work with Spock and JUnit.
She forgot to charge her laptop and ended up using hand written slides and that was cool. :)
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/TrishaGee_LevelUpYourAutomatedTests.pdf&#34;&gt;Slide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Unselfish Testing by Jay Fields(&lt;a href=&#34;https://twitter.com/thejayfields&#34;&gt;@thejayfields&lt;/a&gt;)&lt;/strong&gt; - Jay has written a book on JUnit testing. Jay also emphasized the point of writing better tests. He gave examples about how to make tests better and follow the DRY principle.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/JayFields_UnselfishTesting.pdf&#34;&gt;Slide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Faster Java Objects by Gil Tene(&lt;a href=&#34;https://twitter.com/giltene&#34;&gt;@giltene&lt;/a&gt;)&lt;/strong&gt; -Gil is CTO of Azul systems and talked about faster java objects. Basically they want to have flat memory layout for objects in Java so that they can make them easily streamable. It was a fascinating talk and I learned few things coz I am also working on a problem of reading binary from c structs.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/GilTene_FasterJavaObjects.pdf&#34;&gt;Slide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How Go is making us faster by Wilfried Schobeiri(&lt;a href=&#34;https://twitter.com/nphase&#34;&gt;@nphase&lt;/a&gt;)&lt;/strong&gt; - Wil gave a talk on how MediaMath is using Go lang. I was not present for this talk but I have already seen this couple of time. It is real good talk and brings out some of the great things about Go lang, such as easy to learn, fast, and good concurrency.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/WilfriedSchobeiri_HowGoIsMakingUsFaster.pdf&#34;&gt;Slide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Don&amp;rsquo;t give up on serializability just yet! by Neha Narula(&lt;a href=&#34;https://twitter.com/neha&#34;&gt;@neha&lt;/a&gt;)&lt;/strong&gt; - Neha talked about distributed computing and how serializability plays its part. She talked about Spanner and other distributed systems.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/NehaNarula_DontGiveUpOnSerializabilityJustYet.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Applying the Saga Pattern by Caitie McCaffrey(&lt;a href=&#34;https://twitter.com/caitie&#34;&gt;@caitie&lt;/a&gt;)&lt;/strong&gt; - In this talk Caitie talked about her work with Halo 4 (game) and how she used Saga pattern to solve a distributed computing problem. She also talked about how transactions happen with Saga pattern and how other people can also leverage Saga pattern.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/CaitieMcCaffrey_ApplyingTheSagaPattern.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Coordination-Free Computations by Christopher Meiklejohn(&lt;a href=&#34;https://twitter.com/cmeik&#34;&gt;@cmeik&lt;/a&gt;)&lt;/strong&gt; - This was a very advanced talk on distributed computing where Christopher talked about coordination free computation. He works on Riak team and he showed how he used Riak and CRDT&amp;rsquo;s. He is working on a distributed programming language called LASP.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/ChristopherMeiklejohn_CoordinationFreeComputations.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;From Homogeneous Monolith to Radically Heterogeneous Microservices: The Wunderlist 3 Story by Chad Fowler(&lt;a href=&#34;https://twitter.com/chadfowler&#34;&gt;@chadfowler&lt;/a&gt;)&lt;/strong&gt; - A fun ending keynote from Chad. He talked about how he changed Wunderlist from a monolith to micro services. He talked about clean architecture and how it is important to keep complexity in check in a system. He also talked about how we should take inspiration from our own system(body) and build a system that heal itself.
&lt;a href=&#34;http://gotocon.com/dl/goto-chicago-2015/slides/ChadFowler_FromHomogeneousMonolithToRadicallyHeterogeneousMicroservicesTheWunderlist3Story.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This was a great conference but &lt;strong&gt;diversity&lt;/strong&gt; is still an issue for software industry. There were very few women in audience/speakers. This is a big issue and some speakers even pointed out on stage too. So we all need to work towards making software engineering a more diverse place.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>testing in go lang</title>
      <link>http://varunksaini.com/posts/testing-in-go/</link>
      <pubDate>Sat, 09 May 2015 06:41:00 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/testing-in-go/</guid>
      <description>

&lt;p&gt;Testing is an integral part of software development and as a squad (if you are wondering what is a squad in software company setting, check &lt;a href=&#34;https://vimeo.com/85490944&#34;&gt;Spotify Culture&lt;/a&gt;) in &lt;a href=&#34;https://www.mediamath.com&#34;&gt;MediaMath&lt;/a&gt;, our mantra is that &lt;strong&gt;&amp;ldquo;Regrassion Resistence is a software requirement&amp;rdquo;&lt;/strong&gt; and should be taken care from the start of the project. We give a lot of emphasis on testing the software and having a good test coverage. We have written some tools around &lt;code&gt;go coverage&lt;/code&gt; and &lt;code&gt;go get&lt;/code&gt; &lt;a href=&#34;https://github.com/MediaMath/cove&#34;&gt;cove&lt;/a&gt; to help us with our testing process.&lt;/p&gt;

&lt;p&gt;Go is a batteries included programming language. Go provides testing as part of standard library and that means testing is a first class citizen in Go world. Writing a test in Go is as easy as writing a function. The test function start with &lt;strong&gt;TestXXXXX&lt;/strong&gt; and you can write as many tests as you want. If you have a file such as &lt;strong&gt;&amp;ldquo;github_api.go&amp;rdquo;&lt;/strong&gt;, you can group the tests(create a test suite) for that file in a test file with a name as &lt;strong&gt;&amp;ldquo;github_api_test.go&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Go tests are run with &lt;strong&gt;&lt;code&gt;go test&lt;/code&gt;&lt;/strong&gt; command.&lt;/p&gt;

&lt;h5 id=&#34;a-sample-function:41a817ce30820111ed95bff4b0e3bf7b&#34;&gt;A Sample function:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;package abc

func Add(a, b int) int {
	return a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;test-function:41a817ce30820111ed95bff4b0e3bf7b&#34;&gt;Test function:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;package abc

import &amp;quot;testing&amp;quot;

func TestAdd(t *testing.T) {
	var a, b int = 2, 3
	v := Add(a, b)
	if v != 5 {
		t.Error(&amp;quot;Expected 5, got &amp;quot;, v)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can learn more about Go lang testing package at &lt;a href=&#34;http://golang.org/pkg/testing/&#34;&gt;testing&lt;/a&gt;, if you want to look at the source code &lt;a href=&#34;http://golang.org/src/testing/testing.go&#34;&gt;testing source code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;P.S. In Go documentation, if you want to check package documentation just use &amp;ldquo;&lt;a href=&#34;http://golang.org/pkg/(packagename)&amp;quot;&#34;&gt;http://golang.org/pkg/(packagename)&amp;quot;&lt;/a&gt; and if you want source code &amp;ldquo;&lt;a href=&#34;http://golang.org/src/(packagename)&amp;quot;&#34;&gt;http://golang.org/src/(packagename)&amp;quot;&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pointer type in Go</title>
      <link>http://varunksaini.com/posts/pointer_in_go/</link>
      <pubDate>Sun, 26 Apr 2015 07:40:00 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/pointer_in_go/</guid>
      <description>&lt;p&gt;Go has pointer but no pointer arithmatic. Go is strict about memory safety but sometime you need to get access to pointers. I am working on a task where I am porting some C code to Go. C code is using a lot of pointers and I wanted a way to replicate same in Go. Go has a package called &lt;a href=&#34;https://golang.org/pkg/unsafe/#Pointer&#34;&gt;unsafe&lt;/a&gt; and unsafe package provides a Pointer type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;unsafe&amp;quot;
)

func main() {
	type test struct{}
	var myTest = new(test)
	myPtr := unsafe.Pointer(myTest)
	fmt.Printf(&amp;quot;%T&amp;quot;, myPtr)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;myPtr&lt;/code&gt; is &amp;ldquo;unsafe.Pointer&amp;rdquo; type and if you want to use any operator or cast it to any other pointer, cast it to &lt;code&gt;uintptr&lt;/code&gt; first.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;unsafe&amp;quot;
)

func main() {
	type test struct{}
	var myTest = new(test)
	myPtr := unsafe.Pointer(myTest)

	newMyPtr := uint32(myPtr)
	fmt.Printf(&amp;quot;%T&amp;quot;, newMyPtr)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate an error &amp;ldquo;cannot convert myPtr (type unsafe.Pointer) to type uint32&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;unsafe&amp;quot;
)

func main() {
	type test struct{}
	var myTest = new(test)
	myPtr := unsafe.Pointer(myTest)

	newMyPtr := uint32(uintptr(myPtr))
	fmt.Printf(&amp;quot;%T&amp;quot;, newMyPtr)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine.&lt;/p&gt;

&lt;p&gt;Just be carefull when using unsafe package. If not used properly you might end up looking at memory leaks.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>using io.LimitReader to read a binary file</title>
      <link>http://varunksaini.com/posts/using_io_limitreader/</link>
      <pubDate>Sat, 18 Apr 2015 10:42:00 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/using_io_limitreader/</guid>
      <description>&lt;p&gt;I was working on a problem and wanted to read a very specific chunck of file. I read Go documentation and came through &lt;a href=&#34;http://golang.org/pkg/io/#LimitedReader&#34;&gt;io.LimitReader&lt;/a&gt;. According to official documentation, &amp;ldquo;A LimitedReader reads from R but limits the amount of data returned to just N bytes. Each call to Read updates N to reflect the new amount remaining.&amp;rdquo; and this is what I wanted.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
f, _ := os.Open(&amp;quot;largefile.bin&amp;quot;)
f.Seek(123, 0)

b := make([]byte, 150-123) // remaining length after seek

f.Read(&amp;amp;b)
f.Close()

buf := bytes.NewBuffer(b) // create buffer with the needed bytes

var a float32
binary.Read(buf, binary.LittleEndian, &amp;amp;a)

binary.Read(io.LimitReader(r, 150-123), binary.LittleEndian, &amp;amp;a)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Thinking, Fast and Slow</title>
      <link>http://varunksaini.com/reading/thinking_fast_and_slow/</link>
      <pubDate>Sat, 18 Apr 2015 10:36:30 -0400</pubDate>
      
      <guid>http://varunksaini.com/reading/thinking_fast_and_slow/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/Thinking-Fast-Slow-Daniel-Kahneman/dp/0374533555&#34;&gt;Thinking, Fast and Slow&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get operating system name in Go</title>
      <link>http://varunksaini.com/posts/get-os-name-in-go/</link>
      <pubDate>Sat, 03 Jan 2015 06:13:00 +0000</pubDate>
      
      <guid>http://varunksaini.com/posts/get-os-name-in-go/</guid>
      <description>&lt;p&gt;To get the operating system name where we running a Go program, we can use &lt;strong&gt;runtime&lt;/strong&gt; package. &lt;strong&gt;runtime.GOOS&lt;/strong&gt; return the operating system name. Some people try to use &lt;strong&gt;os.Getenv(&amp;ldquo;GOOS&amp;rdquo;)&lt;/strong&gt; but it is not very reliable. I always use &lt;a href=&#34;http://golang.org/pkg/runtime/&#34;&gt;runtime package&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language=go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;runtime&amp;quot;
)

func main() {
    var goos string = runtime.GOOS
    fmt.Printf(&amp;quot;The operating system is: %s\n&amp;quot;, goos)
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Books I read in 2014</title>
      <link>http://varunksaini.com/posts/books-in-2014/</link>
      <pubDate>Thu, 01 Jan 2015 07:00:00 +0000</pubDate>
      
      <guid>http://varunksaini.com/posts/books-in-2014/</guid>
      <description>&lt;p&gt;I read 7 books (and ton of artilcles in &lt;a href=&#34;http://getpocket.com/&#34;&gt;pockets&lt;/a&gt; app) this year.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src=&#34;http://varunksaini.com/img/pocket.png&#34; alt=&#34;Pocket app stats&#34; title=&#34;Pocket app&#34; style=&#34;width:500px; height: 300px;&#34;&gt;
&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Most of the books that I read were technical ranging on different topics. I read couple of physics books such as &lt;a href=&#34;http://www.amazon.com/gp/product/B00DFL353K/&#34;&gt;Hidden In Plain Sight 2: The Equation of the Universe&lt;/a&gt; and &lt;a href=&#34;http://www.amazon.com/The-Particles-Universe-Jeff-Yee-ebook/dp/B007PM4ZZW&#34;&gt;The particles of universe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I read one fiction book &lt;a href=&#34;http://www.amazon.com/Lethal-Code-Lana-Elkins-Thriller-ebook/dp/B00J9P2EMO/&#34;&gt;Lethal Code&lt;/a&gt;, which I didn&amp;rsquo;t like much. It had a great promise but writing could have been better.&lt;/p&gt;

&lt;p&gt;For 2015, I am planning to read at least 15 books and will try to add some variety this time. I want to read some good fiction, non-fiction, science, technology books. I also have a backlog of 4-5 books that I need to finish this year.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BACKLOG&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Thinking-Fast-Slow-Daniel-Kahneman/dp/0374533555&#34;&gt;Thinking Fast And Slow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Hooked-How-Build-Habit-Forming-Products-ebook/dp/B00LMGLXTS/&#34;&gt;Hooked: How to Build Habit-Forming Products&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X/&#34;&gt;Pragmatic Programmer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Last-Passenger-Manel-Loureiro-ebook/dp/B00KWM7HYI/&#34;&gt;The Last Passenger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Fallow-Season-Hugo-Hunter-ebook/dp/B00JQS1TMK/&#34;&gt;The Fallow Season Of Hugo Hunter&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Some of these books I got from Amazon Prime (Kindle First) and haven&amp;rsquo;t got a chance to read yet.&lt;/p&gt;

&lt;p&gt;I am currently reading 2 books-&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Ultimate-Bar-Book-Comprehensive-Cocktails-ebook/
dp/B003IV8GUY/&#34;&gt;The ultimate bar book&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Way-Go-Thorough-Introduction-Programming-ebook/dp/B0083RVAJW/&#34;&gt;The Way to Go: A Thorough Introduction to the Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And also tons of articles again in 2015.&lt;/p&gt;

&lt;p&gt;Happy Reading All.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>human&#43;&#43;</title>
      <link>http://varunksaini.com/posts/new-human-age/</link>
      <pubDate>Tue, 30 Dec 2014 08:11:15 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/new-human-age/</guid>
      <description>&lt;p&gt;We all talk about an omnipotent AI that will come some time in future and might kill (hypothetically) its masters (humans in this case). I will love to have intelligent robots but I don&amp;rsquo;t see it happening soon. What I believe will happen before AI take over the world, human++, more intelligent humans. If we look carefully we will see subtle changes and technical breakthroughs that are happening around us and pointing towards a brave new world. Some people call this phenomena &amp;ldquo;Singularity&amp;rdquo; but I call it human++.&lt;/p&gt;

&lt;p&gt;There are many cutting edge research and experiments happening to make this a reality. Some of these are mentioned below and well worth you time to check out.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Nano-bots and biological uses&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=6UVet-OCFdI&amp;amp;utm&#34;&gt;Ray Kurzweil and Robert Freitas discuss the future of nanotechnology&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Human Mind interface&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://research.microsoft.com/en-us/um/people/desney/publications/BCIHCI-Chapter1.pdf&#34;&gt;Microsoft research on brain computer interaction&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Exoskeletons&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://biomech.media.mit.edu/portfolio_page/load-bearing-exoskeleton-for-augmentation-of-human-running/&#34;&gt;MIT media lab on exoskeleton and their usage in augmenting humans&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Fight against aging :&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Calico_%28company%29&#34;&gt;Google calico&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;All the things and others will make humans more intelligent, more resilient to disease and other medical issues, more powerful and may be someday Immortal.&lt;/p&gt;

&lt;p&gt;I am no scientist or philosopher, I am just a mere human who sees the things changing around him and trying to connect the dots. It is not easy to understand what is going on but I am an optimist and believe all these changes will make humans better and might one day make us an inter galactic species.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We all know that AI is good, but you know what is best, more intelligent humans.&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working with files in go lang</title>
      <link>http://varunksaini.com/posts/working-with-files-in-go/</link>
      <pubDate>Sat, 13 Dec 2014 06:40:15 -0600</pubDate>
      
      <guid>http://varunksaini.com/posts/working-with-files-in-go/</guid>
      <description>&lt;p&gt;Go makes working with file very easy and file reading is an operation that is used very frequently.&lt;/p&gt;

&lt;p&gt;To open a file in Go, we can use &amp;ldquo;Open&amp;rdquo; function from the &amp;ldquo;os&amp;rdquo; package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language=Go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	file, err := os.Open(&amp;quot;test.txt&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;erros is: &amp;quot;, err)
		return
	}
	defer file.Close()

	size, err := file.Stat()
	if err != nil {
		fmt.Println(&amp;quot;erros is: &amp;quot;, err)
		return
	}

	fs := make([]byte, size.Size())
	_, err = file.Read(fs)
	if err != nil {
		fmt.Println(&amp;quot;erros is: &amp;quot;, err)
		return
	}

	str := string(fs)
	fmt.Println(str)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I really like how you can simply defer the file close operation just after creating a file object. In Go you use &amp;ldquo;defer&amp;rdquo; to do that. any function that use defer will excute in the end. This way we don&amp;rsquo;t have to worry about forgeting closing the file.&lt;/p&gt;

&lt;p&gt;There is a shorter way to read files too.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language=Go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
)

func main() {
	fs, err := ioutil.ReadFile(&amp;quot;test.txt&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;Error is: &amp;quot;, err)
	}

	str := string(fs)
	fmt.Println(str)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to create a file instead of reading it, just use&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language=Go&#34;&gt;file, err := os.Create(&amp;quot;test.txt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Particles of the universe</title>
      <link>http://varunksaini.com/reading/Particles_of_the_universe/</link>
      <pubDate>Sat, 13 Dec 2014 06:32:30 -0400</pubDate>
      
      <guid>http://varunksaini.com/reading/Particles_of_the_universe/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/Particles-Universe-Jeff-Yee-ebook/dp/B007PM4ZZW/&#34;&gt;Particles of the universe&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>