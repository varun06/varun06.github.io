<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Errors on Varun Saini</title>
    <link>https://varunksaini.com/tags/errors/</link>
    <description>Recent content in Errors on Varun Saini</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Thu, 27 Oct 2016 10:40:33 -0500</lastBuildDate>
    
	<atom:link href="https://varunksaini.com/tags/errors/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>how not to handle errors in golang</title>
      <link>https://varunksaini.com/blog/how-not-to-handle-errors-in-golang/</link>
      <pubDate>Thu, 27 Oct 2016 10:40:33 -0500</pubDate>
      
      <guid>https://varunksaini.com/blog/how-not-to-handle-errors-in-golang/</guid>
      <description>People have a love and hate relationship with golang error handling. Golang&amp;rsquo;s use to return values for error handling seems to have as many detractors as admirers. In golang, errors are of immediate interest, so you handle them then and there, so it very common to see code like this -
var user User err := json.Marshal(data, &amp;amp;user) if err != nil { return err }  In a large code base, you see if err !</description>
    </item>
    
  </channel>
</rss>