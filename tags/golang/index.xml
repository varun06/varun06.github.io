<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Never stop learning...</title>
    <link>https://varunksaini.com/tags/golang/index.xml</link>
    <description>Recent content in Golang on Never stop learning...</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://varunksaini.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>question about type assertion in go</title>
      <link>https://varunksaini.com/posts/question-about-type-assertion/</link>
      <pubDate>Wed, 23 Nov 2016 09:47:56 -0600</pubDate>
      
      <guid>https://varunksaini.com/posts/question-about-type-assertion/</guid>
      <description>&lt;p&gt;One of our go app crashed recently because of a bug in &lt;a href=&#34;https://github.com/urfave/cli/&#34;&gt;https://github.com/urfave/cli/&lt;/a&gt;, here is the &lt;a href=&#34;https://github.com/urfave/cli/pull/568&#34;&gt;PR&lt;/a&gt; with fix from my collegue who found the issue. Then we started talking about it internally and found something that&amp;rsquo;s interesting. I understand some of it but not fully so I thought of asking people who might know.&lt;/p&gt;

&lt;p&gt;My question is why &lt;code&gt;bar&lt;/code&gt; works but not &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	var f interface{}
	var b interface{}
	f = foo()
	b = bar()

	if _, ok := f.(func(string) error); ok {
		fmt.Println(&amp;quot;FOUND IT&amp;quot;)
	} else {
		fmt.Println(&amp;quot;DIDNT FIND IT&amp;quot;)
	}

	if _, ok := b.(func(string) error); ok {
		fmt.Println(&amp;quot;FOUND IT&amp;quot;)
	} else {
		fmt.Println(&amp;quot;DIDNT FIND IT&amp;quot;)
	}
}

type FooFunc func(string) error

func foo() func(string) error {
	return func(e string) error {
		return fmt.Errorf(&amp;quot;GOTCHA&amp;quot;)
	}
}

func bar() FooFunc {
	return func(e string) error {
		return fmt.Errorf(&amp;quot;GOTCHA&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/4EfYIMZV-p&#34;&gt;go playground&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using if condition in a defer statement</title>
      <link>https://varunksaini.com/posts/using-if-in-defer/</link>
      <pubDate>Tue, 01 Nov 2016 21:10:59 -0500</pubDate>
      
      <guid>https://varunksaini.com/posts/using-if-in-defer/</guid>
      <description>&lt;p&gt;&lt;code&gt;defer&lt;/code&gt; statement is used to do basic cleanup in go, deferred calls are executed when surrounding function returns.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f, err := os.Open(fileName)
    if err != nil {
        return
    }
defer src.Close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We open a file and then use &lt;code&gt;defer&lt;/code&gt; to close the file handle. Using &lt;code&gt;defer&lt;/code&gt; makes sure that file handle is closed and we don&amp;rsquo;t have any bug in our code.But what if we want to make a decision(conditional) in &lt;code&gt;defer&lt;/code&gt;, is that possible?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt; and &lt;code&gt;named returns&lt;/code&gt; to rescue. Here we are using a form of defer that lets us do something if there is an error and something else if there is not an error.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;errors&amp;quot;
	&amp;quot;fmt&amp;quot;
)

var toggleMe = true

func foo() (boo string, err error) {
	boo = &amp;quot;boo&amp;quot;

	defer func() {
		if err != nil {
			fmt.Printf(boo)
		} else {
			fmt.Println(&amp;quot;bar&amp;quot;)
		}
	}()

	if toggleMe {
		err = errors.New(&amp;quot;an error occurred&amp;quot;)
	}

	return
}

func main() {
	foo()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/ap_zkRpcqQ&#34;&gt;Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t know if it is idiomatic go or not and that&amp;rsquo;s where I need your help, let me know if this is correct to do.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>how not to handle errors in golang</title>
      <link>https://varunksaini.com/posts/how-not-to-handle-errors-in-golang/</link>
      <pubDate>Thu, 27 Oct 2016 10:40:33 -0500</pubDate>
      
      <guid>https://varunksaini.com/posts/how-not-to-handle-errors-in-golang/</guid>
      <description>&lt;p&gt;People have a love and hate relationship with golang error handling. Golang&amp;rsquo;s use to return values for error handling seems to have as many detractors as admirers. In golang, errors are of immediate interest, so you handle them then and there, so it very common to see code like this -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var user User
err := json.Marshal(data, &amp;amp;user)
if err != nil {
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a large code base, you see &lt;code&gt;if err != nil&lt;/code&gt; a lot. So people find ways to minimize that, one such approach is creating a common &lt;code&gt;util&lt;/code&gt; package and then create common convenience error functions such as -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func FailIfNil(t *testing.T, i interface{}) {
	if IsNil(i) {
		//handle error here
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These common functions seems helpful, but again, in a large code base, they get out of hand quickly. Debugging becomes difficult.&lt;/p&gt;

&lt;p&gt;My suggestion would be handle errors when and where you see them. keep things simple and readable. Also if you want to do something with your errors, use a good library such as &lt;a href=&#34;https://github.com/davecheney/errors&#34;&gt;this&lt;/a&gt; one from &lt;a href=&#34;http://dave.cheney.net/&#34;&gt;Dave Cheney&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>